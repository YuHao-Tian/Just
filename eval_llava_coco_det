#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import os, json, argparse, time, re
from typing import List, Dict, Any
import torch
from PIL import Image
from transformers import AutoProcessor, LlavaForConditionalGeneration
from pycocotools.coco import COCO
from pycocotools.cocoeval import COCOeval


# -------------------- helpers --------------------

def clamp01(x: float) -> float:
    return max(0.0, min(1.0, float(x)))


def _extract_first_json_block(text: str) -> str | None:
    """从自由文本里抓取出第一个合法的 JSON 子串。"""
    text = text.strip()
    # 去掉 ``` 包裹
    if text.startswith("```"):
        text = re.sub(r"^```[a-zA-Z0-9]*\n?", "", text).strip()
        if text.endswith("```"):
            text = text[:-3].strip()
    # 先整体试
    try:
        json.loads(text)
        return text
    except Exception:
        pass
    # 从第一个 { 起做括号匹配
    try:
        start = text.index("{")
    except ValueError:
        return None
    stack = 0
    for i in range(start, len(text)):
        ch = text[i]
        if ch == "{":
            stack += 1
        elif ch == "}":
            stack -= 1
            if stack == 0:
                cand = text[start:i + 1]
                try:
                    json.loads(cand)
                    return cand
                except Exception:
                    pass
    return None


def _to_float_conf(c) -> float:
    try:
        if isinstance(c, (list, tuple)) and len(c) > 0:
            c = max(float(x) for x in c)
        return float(c)
    except Exception:
        return 0.0


def _valid_box(b) -> bool:
    if not isinstance(b, (list, tuple)) or len(b) != 4:
        return False
    x1, y1, x2, y2 = map(float, b)
    return (0.0 <= x1 < x2 <= 1.0) and (0.0 <= y1 < y2 <= 1.0)


def iou_xyxy(a: List[float], b: List[float]) -> float:
    ax1, ay1, ax2, ay2 = a
    bx1, by1, bx2, by2 = b
    ix1, iy1 = max(ax1, bx1), max(ay1, by1)
    ix2, iy2 = min(ax2, bx2), min(ay2, by2)
    iw, ih = max(0.0, ix2 - ix1), max(0.0, iy2 - iy1)
    inter = iw * ih
    if inter <= 0:
        return 0.0
    area_a = max(0.0, ax2 - ax1) * max(0.0, ay2 - ay1)
    area_b = max(0.0, bx2 - bx1) * max(0.0, by2 - by1)
    union = area_a + area_b - inter + 1e-12
    return inter / union


def nms_greedy(dets: List[Dict[str, Any]], iou_thr: float) -> List[Dict[str, Any]]:
    if not dets:
        return dets
    dets = sorted(dets, key=lambda d: float(d.get("confidence", 0.0)), reverse=True)
    keep, used = [], [False] * len(dets)
    for i, di in enumerate(dets):
        if used[i]:
            continue
        keep.append(di)
        bi = di["box"]
        for j in range(i + 1, len(dets)):
            if used[j]:
                continue
            bj = dets[j]["box"]
            if iou_xyxy(bi, bj) > iou_thr:
                used[j] = True
    return keep


def parse_llava_json(raw_text: str) -> list[dict]:
    """把 LLaVA 输出的自由文本解析成 detections 列表（可能为空）。"""
    js = _extract_first_json_block(raw_text)
    if js is None:
        return []
    try:
        obj = json.loads(js)
        dets = obj.get("detections", [])
        out = []
        for d in dets:
            lab = d.get("label", None)
            box = d.get("box", None)
            conf = _to_float_conf(d.get("confidence", 0.0))
            if not isinstance(lab, str) or not isinstance(box, (list, tuple)):
                continue
            # 归一化/排序
            if len(box) == 4:
                x1, y1, x2, y2 = map(clamp01, box)
                x1, x2 = min(x1, x2), max(x1, x2)
                y1, y2 = min(y1, y2), max(y1, y2)
                box = [x1, y1, x2, y2]
            out.append({"label": lab.strip(), "box": box, "confidence": conf})
        return out
    except Exception:
        return []


def postprocess_dets(
    dets: list[dict],
    min_conf: float = 0.30,
    nms_iou: float = 0.60,
    max_det: int = 8,
    decimals: int = 3,
) -> list[dict]:
    # 过滤/裁剪/低分
    cleaned = []
    for d in dets:
        lab = d.get("label", "").strip()
        box = d.get("box", None)
        conf = _to_float_conf(d.get("confidence", 0.0))
        if not lab or not isinstance(box, (list, tuple)) or len(box) != 4:
            continue
        x1, y1, x2, y2 = map(clamp01, box)
        x1, x2 = min(x1, x2), max(x1, x2)
        y1, y2 = min(y1, y2), max(y1, y2)
        box = [x1, y1, x2, y2]
        if not _valid_box(box) or conf < min_conf:
            continue
        cleaned.append({"label": lab, "box": box, "confidence": float(conf)})

    if not cleaned:
        return []

    # 类内 NMS
    by_cls = {}
    for d in cleaned:
        by_cls.setdefault(d["label"], []).append(d)
    merged = []
    for lab, group in by_cls.items():
        keep = nms_greedy(group, iou_thr=nms_iou)
        merged.extend(keep)

    # 全局再 NMS 一次（不同类也可能极度重叠）
    merged = nms_greedy(merged, iou_thr=nms_iou)

    # 同类只留最高分
    best_by_cls = {}
    for d in merged:
        lab = d["label"]
        if (lab not in best_by_cls) or (d["confidence"] > best_by_cls[lab]["confidence"]):
            best_by_cls[lab] = d
    merged = list(best_by_cls.values())

    merged.sort(key=lambda d: d["confidence"], reverse=True)
    merged = merged[:max_det]

    for d in merged:
        d["box"] = [round(float(x), decimals) for x in d["box"]]
        d["confidence"] = round(float(d["confidence"]), 3)
    return merged


def gen_and_decode_reply(model, proc, img, prompt, device, max_new_tokens=768) -> str:
    """只解码新生成的部分，避免把提示词一起解出来。"""
    inputs = proc(images=img, text=prompt, return_tensors="pt")
    inputs = {k: (v.to(device) if hasattr(v, "to") else v) for k, v in inputs.items()}
    with torch.inference_mode():
        out = model.generate(
            **inputs,
            max_new_tokens=max_new_tokens,
            do_sample=False,                 # 关闭采样，稳定输出；temperature 将被忽略
            return_dict_in_generate=True
        )
    seq = out.sequences[0]
    gen_ids = seq[inputs["input_ids"].shape[-1]:]
    return proc.decode(gen_ids, skip_special_tokens=True).strip()


def build_canon_label(name2id: Dict[str, int]):
    """把模型可能给出的近义词/变体归一成 COCO 官方小写名称。"""
    name_set = set(name2id.keys())
    no_space_map = {n.replace(" ", ""): n for n in name_set}
    synonyms = {
        "people": "person", "man": "person", "woman": "person", "men": "person", "women": "person",
        "boy": "person", "girl": "person", "kid": "person", "child": "person", "baby": "person",
        "motorbike": "motorcycle", "aeroplane": "airplane", "aircraft": "airplane",
        "trafficlight": "traffic light", "traffic-light": "traffic light",
        "tvmonitor": "tv", "tv monitor": "tv", "television": "tv",
        "cellphone": "cell phone", "mobile phone": "cell phone", "smartphone": "cell phone", "iphone": "cell phone",
        "sofa": "couch", "pottedplant": "potted plant", "potted  plant": "potted plant",
        "diningtable": "dining table", "hand bag": "handbag", "hand-bag": "handbag",
        "wineglass": "wine glass", "wine-glass": "wine glass",
        "tennis-racket": "tennis racket", "baseball-bat": "baseball bat", "baseball-glove": "baseball glove"
    }

    def canon(raw: str):
        s = (raw or "").lower().strip().replace("_", " ").replace("-", " ")
        while "  " in s:
            s = s.replace("  ", " ")
        if s in name_set:
            return s
        if s in synonyms:
            return synonyms[s]
        key = s.replace(" ", "")
        if key in no_space_map:
            return no_space_map[key]
        return None

    return canon


# -------------------- main --------------------

def main():
    ap = argparse.ArgumentParser()
    ap.add_argument("--model-dir", required=True, help="LLaVA 模型目录（基座或合并后的 LoRA）")
    ap.add_argument("--val-ann", required=True, help="COCO instances_val2017.json")
    ap.add_argument("--val-img", required=True, help="COCO val2017 图像目录")
    ap.add_argument("--subset", type=int, default=50, help="评估前 N 张（0=全部）")
    ap.add_argument("--tokens", type=int, default=768, help="生成的最大新 token 数")
    ap.add_argument("--out", required=True, help="COCO 提交格式的检测结果输出 json")
    ap.add_argument("--max-objects", type=int, default=8, help="每图最多保留目标数")
    ap.add_argument("--nms-iou", type=float, default=0.6, help="NMS IoU 阈值")
    ap.add_argument("--min-conf", type=float, default=0.30, help="最小置信度")
    ap.add_argument("--show-raw", action="store_true", help="打印前几张的原始回复")
    args = ap.parse_args()

    device = "cuda" if torch.cuda.is_available() else "cpu"
    dtype = torch.bfloat16 if device == "cuda" else torch.float32

    print(f"[info] loading model from: {args.model_dir}")
    model = LlavaForConditionalGeneration.from_pretrained(args.model_dir, torch_dtype=dtype).to(device).eval()
    proc = AutoProcessor.from_pretrained(args.model_dir)

    coco = COCO(args.val_ann)
    cats = coco.loadCats(coco.getCatIds())
    class_names = [c["name"] for c in cats]
    name2id = {c["name"].lower(): c["id"] for c in cats}
    canon_label = build_canon_label(name2id)
    allowed = set(name2id.keys())

    imgs = coco.dataset["images"]
    ids = [im["id"] for im in imgs]
    info = {im["id"]: (im["file_name"], im.get("width", 0), im.get("height", 0)) for im in imgs}
    if args.subset and args.subset > 0:
        ids = ids[:args.subset]
    print(f"[info] subset = {len(ids)} images")

    # 统一英文指令（不在提示里放 JSON 示例，减少“抄模板”）
    instr = (
        "You are an object detection assistant. "
        "Return ONLY a valid JSON with key 'detections'. "
        'Each item: {"label": <one COCO class>, "box": [x1,y1,x2,y2], "confidence": [0,1]}. '
        "Coordinates are normalized to [0,1] with (x1,y1)=top-left and (x2,y2)=bottom-right. "
        f"At most {args.max_objects} objects. Do NOT repeat the same class or the same box. "
        "If two boxes IoU>0.6, keep the one with higher confidence. "
        "Use ONLY these labels (singular, English): " + ", ".join(class_names) + ". "
        'If nothing is found, return {"detections":[]}. '
        "Output JSON only."
    )

    all_dt = []
    ok_json = 0
    t0 = time.time()

    for k, img_id in enumerate(ids, 1):
        fn, W, H = info[img_id]
        path = os.path.join(args.val_img, fn)
        img = Image.open(path).convert("RGB")

        # 一图一词：<image> + 指令
        messages = [{"role": "user", "content": [{"type": "image"}, {"type": "text", "text": instr}]}]
        prompt = proc.apply_chat_template(messages, add_generation_prompt=True)

        txt = gen_and_decode_reply(model, proc, img, prompt, device, max_new_tokens=args.tokens)
        if args.show_raw and k <= 5:
            print(f"==== RAW REPLY (image {k}: {fn}) ====")
            print(txt)

        raw_dets = parse_llava_json(txt)
        ok_json += 1  # 能被解析（即使 detections 为空）就计入

        # label 归一 + 过滤非法类名
        parsed = []
        for d in raw_dets:
            lab = canon_label(d.get("label", ""))
            if lab is None or lab not in allowed:
                continue
            box = d.get("box", None)
            conf = _to_float_conf(d.get("confidence", 0.0))
            if not isinstance(box, (list, tuple)) or len(box) != 4:
                continue
            x1, y1, x2, y2 = map(clamp01, box)
            x1, x2 = min(x1, x2), max(x1, x2)
            y1, y2 = min(y1, y2), max(y1, y2)
            if x2 <= x1 or y2 <= y1:
                continue
            parsed.append({"label": lab, "box": [x1, y1, x2, y2], "confidence": conf})

        # 去重 + NMS + 截断
        final_dets = postprocess_dets(
            parsed, min_conf=args.min_conf, nms_iou=args.nms_iou, max_det=args.max_objects, decimals=3
        )

        # 写入 COCO 格式
        for d in final_dets:
            x1, y1, x2, y2 = d["box"]
            x, y, w, h = x1 * W, y1 * H, (x2 - x1) * W, (y2 - y1) * H
            all_dt.append({
                "image_id": int(img_id),
                "category_id": name2id[d["label"]],
                "bbox": [float(x), float(y), float(w), float(h)],
                "score": float(d["confidence"])
            })

        print(f"[{k}/{len(ids)}] dt={len(final_dets)}")

    # 保存结果
    with open(args.out, "w") as f:
        json.dump(all_dt, f)
    print(f"[saved] detections -> {args.out}")
    jsucc = ok_json / len(ids) if len(ids) else 0.0
    print(f"[info] JSON success rate: {ok_json}/{len(ids)} = {jsucc:.2%}")
    print(f"[time] processed {len(ids)} images in {time.time() - t0:.1f}s")

    if len(all_dt) == 0:
        print("[warn] No detections recorded. mAP will be 0.0.")
        return

    # COCO mAP
    res = coco.loadRes(args.out)
    e = COCOeval(coco, res, "bbox")
    e.evaluate(); e.accumulate(); e.summarize()
    mAP, AP50, AR100 = float(e.stats[0]), float(e.stats[1]), float(e.stats[8])
    print(f"[metrics] mAP@[.50:.95]={mAP:.4f} | AP50={AP50:.4f} | AR@100={AR100:.4f}")


if __name__ == "__main__":
    main()
