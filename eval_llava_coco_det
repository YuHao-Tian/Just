#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import os, json, argparse, time, re
from typing import List, Dict, Any, Optional
import torch
from PIL import Image
from transformers import AutoProcessor, LlavaForConditionalGeneration
from pycocotools.coco import COCO
from pycocotools.cocoeval import COCOeval


# -------------------- helpers --------------------

def clamp01(x: float) -> float:
    return max(0.0, min(1.0, float(x)))


def extract_first_json_block(text: str) -> Optional[str]:
    """从自由文本里抓第一个合法 JSON 子串；支持去除 ``` 包裹。"""
    text = text.strip()
    # 去掉 ``` 包裹
    if text.startswith("```"):
        text = re.sub(r"^```[a-zA-Z0-9]*\n?", "", text).strip()
        if text.endswith("```"):
            text = text[:-3].strip()
    # 直接整体试
    try:
        json.loads(text)
        return text
    except Exception:
        pass
    # 从第一个 { 起做括号匹配
    try:
        start = text.index("{")
    except ValueError:
        return None
    stack = 0
    for i in range(start, len(text)):
        ch = text[i]
        if ch == "{":
            stack += 1
        elif ch == "}":
            stack -= 1
            if stack == 0:
                cand = text[start:i + 1]
                try:
                    json.loads(cand)
                    return cand
                except Exception:
                    pass
    return None


def iou_xyxy(a: List[float], b: List[float]) -> float:
    ax1, ay1, ax2, ay2 = a
    bx1, by1, bx2, by2 = b
    ix1, iy1 = max(ax1, bx1), max(ay1, by1)
    ix2, iy2 = min(ax2, bx2), min(ay2, by2)
    iw, ih = max(0.0, ix2 - ix1), max(0.0, iy2 - iy1)
    inter = iw * ih
    if inter <= 0:
        return 0.0
    area_a = max(0.0, ax2 - ax1) * max(0.0, ay2 - ay1)
    area_b = max(0.0, bx2 - bx1) * max(0.0, by2 - by1)
    union = area_a + area_b - inter + 1e-12
    return inter / union


def nms_greedy(dets: List[Dict[str, Any]], iou_thr: float) -> List[Dict[str, Any]]:
    if not dets:
        return dets
    dets = sorted(dets, key=lambda d: float(d.get("confidence", 0.0)), reverse=True)
    keep, used = [], [False] * len(dets)
    for i, di in enumerate(dets):
        if used[i]:
            continue
        keep.append(di)
        bi = di["box"]
        for j in range(i + 1, len(dets)):
            if used[j]:
                continue
            bj = dets[j]["box"]
            if iou_xyxy(bi, bj) > iou_thr:
                used[j] = True
    return keep


def to_float_conf(c, box=None) -> float:
    """把奇怪的 confidence 统一成标量；若与 box 完全相同则给一个默认 0.5。"""
    try:
        if isinstance(c, (list, tuple)) and len(c) > 0:
            if len(c) == 4 and box is not None:
                try:
                    bx = [round(float(x), 3) for x in box]
                    cx = [round(float(x), 3) for x in c]
                    if bx == cx:
                        return 0.5
                except Exception:
                    pass
            return float(max(float(x) for x in c))
        return float(c)
    except Exception:
        return 0.0


def parse_llava_json(raw_text: str) -> list[dict]:
    """把 LLaVA 输出的自由文本解析成 detections 列表（可能为空）。"""
    js = extract_first_json_block(raw_text)
    if js is None:
        return []
    try:
        obj = json.loads(js)
        dets = obj.get("detections", [])
        out = []
        for d in dets:
            lab = d.get("label", None)
            box = d.get("box", None)
            if not isinstance(lab, str) or not isinstance(box, (list, tuple)) or len(box) != 4:
                continue
            x1, y1, x2, y2 = map(clamp01, box)
            x1, x2 = min(x1, x2), max(x1, x2)
            y1, y2 = min(y1, y2), max(y1, y2)
            if not (0.0 <= x1 < x2 <= 1.0 and 0.0 <= y1 < y2 <= 1.0):
                continue
            box_xyxy = [x1, y1, x2, y2]
            conf = to_float_conf(d.get("confidence", 0.0), box=box_xyxy)
            out.append({"label": lab.strip(), "box": box_xyxy, "confidence": float(conf)})
        return out
    except Exception:
        return []


def postprocess_dets(
    dets: list[dict],
    min_conf: float = 0.35,
    nms_iou: float = 0.55,
    max_det: int = 6,
    decimals: int = 3,
) -> list[dict]:
    """过滤低分、类内 NMS、全局 NMS、同类仅保留最高分、最多保留 max_det。"""
    if not dets:
        return []
    # 低分 & 合法性
    cleaned = []
    for d in dets:
        lab = d.get("label", "").strip()
        box = d.get("box", None)
        conf = to_float_conf(d.get("confidence", 0.0), box=box)
        if not lab or not isinstance(box, (list, tuple)) or len(box) != 4:
            continue
        x1, y1, x2, y2 = map(clamp01, box)
        x1, x2 = min(x1, x2), max(x1, x2)
        y1, y2 = min(y1, y2), max(y1, y2)
        if not (0.0 <= x1 < x2 <= 1.0 and 0.0 <= y1 < y2 <= 1.0):
            continue
        if conf < min_conf:
            continue
        cleaned.append({"label": lab, "box": [x1, y1, x2, y2], "confidence": float(conf)})

    if not cleaned:
        return []

    # 类内 NMS
    by_cls = {}
    for d in cleaned:
        by_cls.setdefault(d["label"], []).append(d)
    merged = []
    for lab, group in by_cls.items():
        keep = nms_greedy(group, iou_thr=nms_iou)
        merged.extend(keep)

    # 全局再 NMS 一次
    merged = nms_greedy(merged, iou_thr=nms_iou)

    # 同类只留最高分
    best_by_cls = {}
    for d in merged:
        lab = d["label"]
        if (lab not in best_by_cls) or (d["confidence"] > best_by_cls[lab]["confidence"]):
            best_by_cls[lab] = d
    merged = list(best_by_cls.values())

    # 截断
    merged.sort(key=lambda d: d["confidence"], reverse=True)
    merged = merged[:max_det]

    # 美化
    for d in merged:
        d["box"] = [round(float(x), decimals) for x in d["box"]]
        d["confidence"] = round(float(d["confidence"]), 3)
    return merged


# -------------------- main --------------------

def main():
    ap = argparse.ArgumentParser()
    ap.add_argument("--model-dir", required=True, help="LLaVA 模型目录（基座或合并后的 LoRA）")
    ap.add_argument("--val-ann", required=True, help="COCO instances_val2017.json")
    ap.add_argument("--val-img", required=True, help="COCO val2017 图像目录")
    ap.add_argument("--subset", type=int, default=50, help="评估前 N 张（0=全部）")
    ap.add_argument("--tokens", type=int, default=768, help="生成的最大新 token 数")
    ap.add_argument("--out", required=True, help="COCO 提交格式的检测结果输出 json")
    ap.add_argument("--max-objects", type=int, default=6, help="每图最多保留目标数")
    ap.add_argument("--nms-iou", type=float, default=0.55, help="NMS IoU 阈值（类内与全局）")
    ap.add_argument("--min-conf", type=float, default=0.35, help="最小置信度")
    ap.add_argument("--show-raw", action="store_true", help="打印前几张的原始回复")
    args = ap.parse_args()

    device = "cuda" if torch.cuda.is_available() else "cpu"
    dtype = torch.bfloat16 if device == "cuda" else torch.float32

    print(f"[info] loading model from: {args.model_dir}")
    model = LlavaForConditionalGeneration.from_pretrained(args.model_dir, torch_dtype=dtype).to(device).eval()
    proc = AutoProcessor.from_pretrained(args.model_dir)

    coco = COCO(args.val_ann)
    cats = coco.loadCats(coco.getCatIds())
    class_names = [c["name"] for c in cats]
    name2id = {c["name"].lower(): c["id"] for c in cats}

    imgs = coco.dataset["images"]
    ids = [im["id"] for im in imgs]
    info = {im["id"]: (im["file_name"], im.get("width", 0), im.get("height", 0)) for im in imgs}
    if args.subset and args.subset > 0:
        ids = ids[:args.subset]
    print(f"[info] subset = {len(ids)} images")

    # 英文指令（不放 JSON 示例，减少“照抄模板”）
    instr = (
        "You are an object detection assistant. "
        "Return ONLY a valid JSON with key 'detections'. "
        'Each item: {"label": <one COCO class>, "box": [x1,y1,x2,y2], "confidence": [0,1]}. '
        "Coordinates are normalized to [0,1] with (x1,y1)=top-left and (x2,y2)=bottom-right. "
        f"At most {args.max_objects} objects. Do NOT repeat the same class or the same box. "
        "If two boxes IoU>0.6, keep the one with higher confidence. "
        "Use ONLY these labels (singular, English): " + ", ".join(class_names) + ". "
        'If nothing is found, return {"detections":[]}. '
        "Output JSON only."
    )

    all_dt = []
    ok_json = 0
    t0 = time.time()

    for k, img_id in enumerate(ids, 1):
        fn, W, H = info[img_id]
        path = os.path.join(args.val_img, fn)
        img = Image.open(path).convert("RGB")

        # 一图一词：<image> + 指令
        messages = [{"role": "user", "content": [{"type": "image"}, {"type": "text", "text": instr}]}]
        prompt = proc.apply_chat_template(messages, add_generation_prompt=True)

        # 生成并只解码“新增”部分
        inputs = proc(images=img, text=prompt, return_tensors="pt")
        inputs = {k: (v.to(device) if hasattr(v, "to") else v) for k, v in inputs.items()}
        with torch.inference_mode():
            out = model.generate(
                **inputs,
                max_new_tokens=args.tokens,
                do_sample=False,
                return_dict_in_generate=True
            )
        seq = out.sequences[0]
        gen_ids = seq[inputs["input_ids"].shape[-1]:]
        txt = proc.decode(gen_ids, skip_special_tokens=True).strip()

        if args.show_raw and k <= 5:
            print(f"==== RAW REPLY (image {k}: {fn}) ====")
            print(txt)

        raw_dets = parse_llava_json(txt)
        ok_json += 1  # 只要能解析就算成功（即使 detections 为空）

        # 归一/过滤/去重
        final_dets = postprocess_dets(
            raw_dets, min_conf=args.min_conf, nms_iou=args.nms_iou,
            max_det=args.max_objects, decimals=3
        )

        # 写入 COCO 格式
        for d in final_dets:
            x1, y1, x2, y2 = d["box"]
            x, y, w, h = x1 * W, y1 * H, (x2 - x1) * W, (y2 - y1) * H
            all_dt.append({
                "image_id": int(img_id),
                "category_id": name2id[d["label"].lower()],
                "bbox": [float(x), float(y), float(w), float(h)],
                "score": float(d["confidence"])
            })

        print(f"[{k}/{len(ids)}] dt={len(final_dets)}")

    # 保存结果
    with open(args.out, "w") as f:
        json.dump(all_dt, f)
    print(f"[saved] detections -> {args.out}")
    jsucc = ok_json / len(ids) if len(ids) else 0.0
    print(f"[info] JSON success rate: {ok_json}/{len(ids)} = {jsucc:.2%}")
    print(f"[time] processed {len(ids)} images in {time.time() - t0:.1f}s")

    if len(all_dt) == 0:
        print("[warn] No detections recorded. mAP will be 0.0.")
        return

    # COCO mAP 评估
    res = coco.loadRes(args.out)
    e = COCOeval(coco, res, "bbox")
    e.evaluate(); e.accumulate(); e.summarize()
    mAP, AP50, AR100 = float(e.stats[0]), float(e.stats[1]), float(e.stats[8])
    print(f"[metrics] mAP@[.50:.95]={mAP:.4f} | AP50={AP50:.4f} | AR@100={AR100:.4f}")


if __name__ == "__main__":
    main()
